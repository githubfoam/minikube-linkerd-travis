---
sudo: required
dist: bionic
env:
  global:
  #fleet_script_minikube_tasks
  - KUBECTL_VERSION=1.18.1
  - KUBERNETES_VERSION=1.18.1
  - MINIKUBE_VERSION=1.8.1
  - CHANGE_MINIKUBE_NONE_USER=true #(bool) automatically change ownership of ~/.minikube to the value of $SUDO_USER https://minikube.sigs.k8s.io/docs/handbook/config/
  - MINIKUBE_WANTREPORTERRORPROMPT=false
  - MINIKUBE_WANTUPDATENOTIFICATION=false #(bool) sets whether the user wants an update notification for new minikube versions https://minikube.sigs.k8s.io/docs/handbook/config
  - MINIKUBE_HOME=$HOME #(string) sets the path for the .minikube directory that minikube uses for state/configuration. Please note: this is used only by minikube https://minikube.sigs.k8s.io/docs/handbook/config
  - KUBECONFIG=$HOME/.kube/config
  # - ISTIO_VERSION=1.6.0
notifications:
  slack:
    on_failure: always

fleet_script_minikube_knative_istio_serverless_tasks : &fleet_script_minikube_knative_istio_serverless_tasks
      script:
          - set -eux #safety for script
          # - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v1.18.1/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          # - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v1.8.1/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          # - mkdir -p $HOME/.kube $HOME/.minikube
          # - touch $KUBECONFIG
          # --vm-driver=none, doesn't use a VM, but containers
          # - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v1.18.1 #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --memory=8192 --cpus=4 --vm-driver="virtualbox" #virtualbox not applicable 4 travisci
          - |
            sudo -E minikube start \
            --memory=8192 --cpus=4 \
            --kubernetes-version=v$KUBERNETES_VERSION \
            --vm-driver=none --bootstrapper=kubeadm --alsologtostderr \
            --extra-config=apiserver.enable-admission-plugins="LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook"
          - minikube update-context
          - |
            echo "Waiting for Kubernetes to be ready ..."
            for i in {1..150}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
                 kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          # - minikube update-context --profile=minikube
          # - "sudo chown -R travis: /home/travis/.minikube/"
          # - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "=========================================================================================="
          - echo "================================Install istio=========================================================="
          - curl -L https://raw.githubusercontent.com/knative/serving/v0.1.1/third_party/istio-0.8.0/istio.yaml | sed 's/LoadBalancer/NodePort/'  | kubectl apply -f - ## Install Istio
          - kubectl label namespace default istio-injection=enabled # Label the default namespace with istio-injection=enabled
          - |
            echo "Waiting for Istio to be ready ..."
            for i in {1..30}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=istio-system -listio=pilot|grep Running ; then
                break
              fi
              sleep 10
            done
          - kubectl get pods --namespace=istio-system
          - echo "================================Install knative=========================================================="
          - curl -L https://github.com/knative/serving/releases/download/v0.1.1/release-lite.yaml | sed 's/LoadBalancer/NodePort/' | kubectl apply -f
          - |
            for i in {1..60}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=knative-serving -lapp=activator|grep Running && \
              	 kubectl get pods --namespace=knative-serving -lapp=controller|grep Running && \
              	 kubectl get pods --namespace=knative-serving -lapp=webhook|grep Running ; then
                break
              fi
              sleep 5
            done
          - kubectl get pods --namespace=knative-serving
          - echo "=========================================================================================="
          - - echo 'Knative ingress:' $(minikube ip):$(kubectl get svc knative-ingressgateway -n istio-system -o 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')
fleet_script_minikube_knative_ambassador_serverless_tasks : &fleet_script_minikube_knative_ambassador_serverless_tasks
      script:
          - set -eux #safety for script
          # - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v1.18.1/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          # - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v1.8.1/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          # - mkdir -p $HOME/.kube $HOME/.minikube
          # - touch $KUBECONFIG
          # --vm-driver=none, doesn't use a VM, but containers
          # - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v1.18.1 #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --memory=8192 --cpus=4 --vm-driver="virtualbox" #virtualbox not applicable 4 travisci
          - |
            sudo -E minikube start \
            --memory=8192 --cpus=4 \
            --kubernetes-version=v$KUBERNETES_VERSION \
            --vm-driver=none --bootstrapper=kubeadm --alsologtostderr \
            --extra-config=apiserver.enable-admission-plugins="LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook"
          - minikube update-context
          - |
            echo "Waiting for Kubernetes to be ready ..."
            for i in {1..150}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
                 kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          # - minikube update-context --profile=minikube
          # - "sudo chown -R travis: /home/travis/.minikube/"
          # - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "=========================================================================================="
          - echo "================================Install istio=========================================================="
          - curl -L https://raw.githubusercontent.com/knative/serving/v0.1.1/third_party/istio-0.8.0/istio.yaml | sed 's/LoadBalancer/NodePort/'  | kubectl apply -f - ## Install Istio
          - kubectl label namespace default istio-injection=enabled # Label the default namespace with istio-injection=enabled
          - |
            echo "Waiting for Istio to be ready ..."
            for i in {1..30}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=istio-system -listio=pilot|grep Running ; then
                break
              fi
              sleep 10
            done
          - kubectl get pods --namespace=istio-system
          - echo "================================Install knative=========================================================="
          - curl -L https://github.com/knative/serving/releases/download/v0.1.1/release-lite.yaml | sed 's/LoadBalancer/NodePort/' | kubectl apply -f
          - |
            for i in {1..60}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=knative-serving -lapp=activator|grep Running && \
              	 kubectl get pods --namespace=knative-serving -lapp=controller|grep Running && \
              	 kubectl get pods --namespace=knative-serving -lapp=webhook|grep Running ; then
                break
              fi
              sleep 5
            done
          - kubectl get pods --namespace=knative-serving
          - echo "=========================================================================================="
          - - echo 'Knative ingress:' $(minikube ip):$(kubectl get svc knative-ingressgateway -n istio-system -o 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')
fleet_script_minikube_knative_tasks : &fleet_script_minikube_knative_tasks
      script:
          # - set -eux #safety for script
          - set -e #safety for script
          - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          # --vm-driver=none, doesn't use a VM, but containers
          # - sudo minikube start --profile=minikube  --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          - |
            sudo minikube start \
             --profile=minikube \
             --disk-size=30g \
             --vm-driver=none \
             --extra-config=apiserver.enable-admission-plugins="LimitRanger,NamespaceExists,NamespaceLifecycle,ResourceQuota,ServiceAccount,DefaultStorageClass,MutatingAdmissionWebhook" \
             --kubernetes-version=v$KUBERNETES_VERSION
          # The 'none' driver does not respect the --cpus flag ! The 'none' driver does not respect the --memory flag
          # - sudo minikube start --profile=minikube --memory=8192 --cpus=4 --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          # - sudo minikube start --memory=8192 --cpus=4 --vm-driver="virtualbox" #virtualbox not applicable 4 travisci
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl cluster-info
          - minikube status
          - echo "=========================================================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "================================Install istio=========================================================="
          - export ISTIO_VERSION=1.4.6
          - curl -L https://git.io/getLatestIstio | sh - && cd istio-${ISTIO_VERSION}
          - for i in install/kubernetes/helm/istio-init/files/crd*yaml; do kubectl apply -f $i; done #Install Istio CRDs
          # - kubectl create ns istio-system #Create istio-system namespace
          # - kubectl label ns istio-system istio-injection=disabled
          #Create istio-system namespace
          - |
            cat <<EOF | sudo kubectl apply -f -
            apiVersion: v1
            kind: Namespace
            metadata:
              name: istio-system
              labels:
                istio-injection: disabled
            EOF
          - sudo apt install snapd -y && sudo snap install helm --classic # Install  helm 3.2.1 from Snapcrafters installed
          # https://knative.dev/docs/install/installing-istio/  Installing Istio without sidecar injection Generate istio-lean.yaml
          - |
            sudo helm template --namespace=istio-system \
            	  --set prometheus.enabled=false \
                --set mixer.enabled=false \
                --set mixer.policy.enabled=false \
                --set mixer.telemetry.enabled=false \
                `# Pilot doesn't need a sidecar.` \
                --set pilot.sidecar=false \
                --set pilot.resources.requests.memory=128Mi \
                `# Disable galley (and things requiring galley).` \
                --set galley.enabled=false \
                --set global.useMCP=false \
                `# Disable security / policy.` \
                --set security.enabled=false \
                --set global.disablePolicyChecks=true \
                `# Disable sidecar injection.` \
                --set sidecarInjectorWebhook.enabled=false \
                --set global.proxy.autoInject=disabled \
                --set global.omitSidecarInjectorConfigMap=true \
                --set gateways.istio-ingressgateway.autoscaleMin=1 \
                --set gateways.istio-ingressgateway.autoscaleMax=2 \
                `# Set pilot trace sampling to 100%` \
                --set pilot.traceSampling=100 \
                --set global.mtls.auto=false \
                install/kubernetes/helm/istio \
                > ./istio-lean.yaml
          - kubectl apply -f istio-lean.yaml && cd .. # Install Istio using istio-lean.yaml
          - |
            echo "Waiting for Istio to be ready ..."
            for i in {1..30}; do # Timeout after 5 minutes
              if kubectl get pods --namespace=istio-system -listio=pilot|grep Running ; then
                break
              fi
              sleep 30
            done
          - kubectl get pods --namespace istio-system #Verifying your Istio install
          - kubectl get svc -nistio-system #look up the external IP address that Istio received
          # https://knative.dev/docs/install/any-kubernetes-cluster/ Installing the Serving component
          # - echo "================================Install knative Installing the Serving component =========================================================="
          # - |
          #   sudo kubectl apply \
          #    --filename https://github.com/knative/serving/releases/download/v0.14.0/serving-crds.yaml \ #Install the Custom Resource Definitions (aka CRDs)
          #    --filename https://github.com/knative/serving/releases/download/v0.14.0/serving-core.yaml \ #Install the core components of Serving
          #    `#--filename https://github.com/knative/serving/releases/download/v0.11.0/monitoring.yaml` # Monitoring was disabled because it's too heavy for Minikube
          # - echo "================================Install knative=========================================================="
          # - |
          #   sudo kubectl apply \
          #    --filename https://github.com/knative/serving/releases/download/v0.11.0/serving.yaml \
          #    --filename https://github.com/knative/eventing/releases/download/v0.11.0/release.yaml \
          #    `#--filename https://github.com/knative/serving/releases/download/v0.11.0/monitoring.yaml` # Monitoring was disabled because it's too heavy for Minikube
          # - echo "================================Istio External IP Address=========================================================="
          # - export INGRESSGATEWAY=istio-ingressgateway
          # - export EXTERNAL_IP_ADDRESS=$(minikube ip):$(kubectl get svc $INGRESSGATEWAY --namespace istio-system --output 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')
          # - echo "EXTERNAL_IP_ADDRESS=$EXTERNAL_IP_ADDRESS"
          # - echo "To export Istio External IP Address:         export EXTERNAL_IP_ADDRESS=$EXTERNAL_IP_ADDRESS"
          # - kubectl get pods --all-namespaces
          # - |
          #   for i in {1..30}; do # Timeout after 5 minutes
          #     if kubectl get pods --namespace=knative-serving -lapp=activator|grep Running && \
          #     	 kubectl get pods --namespace=knative-serving -lapp=controller|grep Running && \
          #     	 kubectl get pods --namespace=knative-serving -lapp=webhook|grep Running ; then
          #       break
          #     fi
          #     sleep 10
          #   done
          # - kubectl get pods --namespace=knative-serving
          # - echo "=========================================================================================="
          # - echo 'Knative ingress:' $(minikube ip):$(kubectl get svc knative-ingressgateway -n istio-system -o 'jsonpath={.spec.ports[?(@.port==80)].nodePort}')
fleet_script_linkerd_tasks : &fleet_script_linkerd_tasks
      script:
          - egrep -c '(vmx|svm)' /proc/cpuinfo | echo "virtualization is  supported" | echo "virtualization is not supported"
          - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          - curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          # - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          # - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl version --client #ensure the version
          - kubectl cluster-info
          - minikube status
          - echo "============================Waiting for Kubernetes to be ready=============================================================="
          - |
            for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
              if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
                 kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
                break
              fi
              sleep 2
            done
          - echo "=========================================================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "==================================Install linkerd========================================================" #https://linkerd.io/2/getting-started/
          - curl -sL https://run.linkerd.io/install | sudo sh #Client installation, Linkerd stable-2.7.1 was successfully installed
          # - echo 'export PATH=$PATH:$HOME/.linkerd2/bin' | sudo tee -a ~/.bashrc
          # - source ~/.bashrc
          - export PATH=$PATH:/home/travis/.linkerd2/bin
          - linkerd version  #Server version: unavailable
          - linkerd check --pre #validate that Linkerd can be installed,  check that the kubernets cluster is configured correctly and it's ready to install the control plane
          - 'sudo linkerd install | sudo kubectl apply -f -' # install the control plane into its own namespace (by default, linkerd)
          - echo "============================Waiting for linkerd to be ready=============================================================="
          - |
            for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
              if kubectl get pods --namespace=linkerd |grep Running ; then
                break
              fi
              sleep 2
            done
          - sudo linkerd check #validate everything worked!
          # Post http://localhost:34767/api/v1/Version: context deadline exceeded
          # This check indicates a connectivity failure between the cli and the Linkerd control plane.To verify connectivity, manually connect to the controller pod
          # https://linkerd.io/2/tasks/troubleshooting/#l5d-existence-api%20for%20hints
          - |
            kubectl -n linkerd port-forward \
              $(kubectl -n linkerd get po \
                  --selector=linkerd.io/control-plane-component=controller \
                  -o jsonpath='{.items[*].metadata.name}') \
              9995:9995 & # background
          - curl localhost:9995/metrics #curl the /metrics endpoint
          - kubectl -n linkerd get deploy #what components were installed
          - linkerd dashboard & #
          - linkerd -n linkerd top deploy/linkerd-web #the traffic you're generating by looking at the dashboard itself
          # # demo1
          # - kubectl create ns booksapp #Deploy the demo app "Books"
          # - 'curl -sL https://run.linkerd.io/booksapp.yml | kubectl -n booksapp apply -f -'
          # - echo "============================Waiting for linkerd to be ready=============================================================="
          # - |
          #   for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
          #     if kubectl get pods --namespace=booksapp |grep Running ; then
          #       break
          #     fi
          #     sleep 2
          #   done
          # - kubectl get all -n booksapp
          # - kubectl -n booksapp rollout status deploy webapp
          # #Apply the service mesh to the app
          # - 'kubectl -n booksapp rollout status deploy webapp' #get the yaml file of the running deployment, pass it to linkerd inject that will inject the linkerd-proxy into the pods and then pass back the new yaml to kubectl.
          # - linkerd stat deployments -n booksapp #use CLI to inspect the status
          # # - linkerd tap ns/booksapp #similar to tcpdump
          # - kubectl -n booksapp describe pod books # inspect one of the pods with the injected sidecar
          # # demo2
          # - kubectl apply -f https://raw.githubusercontent.com/binc75/linkerdDemo/master/autoinject-ns.yaml #Create the ns in k8s
          # - kubectl apply -f https://raw.githubusercontent.com/binc75/linkerdDemo/master/nginx-deployment.yaml -n autoinject #verify that the pods on the namespace are actually injected with the linkerd proxy
          # - kubectl get pods -n autoinject -o=jsonpath='{.items[0].spec.containers[*].name}' #inspect the pods to see the injected container, my-nginx linkerd-proxy
          # - linkerd stat pods -n autoinject
          # # demo3
          # - 'curl -sL https://run.linkerd.io/emojivoto.yml | kubectl apply -f -'
          # - echo "============================Waiting for emojivoto to be ready=============================================================="
          # - |
          #   for i in {1..150}; do # Timeout after 5 minutes, 150x2=300 secs
          #     if kubectl get pods --namespace=emojivoto |grep Running ; then
          #       break
          #     fi
          #     sleep 2
          #   done
          # - kubectl -n emojivoto port-forward svc/web-svc 8080:80 #forward web-svc locally to port 8080
          # - curl http://localhost:8080 #The emojivoto application is a standalone Kubernetes application that uses a mix of gRPC and HTTP calls to allow the users to vote on their favorite emojis
          # - 'kubectl get -n emojivoto deploy -o yaml | linkerd inject -| kubectl apply -f -' #add Linkerd to emojivoto
          # - linkerd -n emojivoto check --proxy #
          # - linkerd -n emojivoto stat deploy # see live traffic metrics
          # - linkerd -n emojivoto top deploy #use top to get a real-time view of which paths are being called
          # - linkerd -n emojivoto tap deploy/web #use tap shows the stream of requests across a single pod, deployment, or even everything in the emojivoto namespace

fleet_script_minikube_latest_tasks : &fleet_script_minikube_latest_tasks
      script:
          # global env variables
          # - grep -E --color 'vmx|svm' /proc/cpuinfo #check if virtualization is supported on Linux
          - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          - curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          # - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          # - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl version --client #ensure the version
          - kubectl cluster-info
          - minikube status
          - echo "=========================================================================================="
          # - sudo -E minikube start --kubernetes-version=v$KUBERNETES_VERSION --vm-driver=none --bootstrapper=kubeadm --alsologtostderr
          # - |
          #   echo "Waiting for Kubernetes to be ready ..."
          #   for i in {1..150}; do # Timeout after 5 minutes
          #     if kubectl get pods --namespace=kube-system -lcomponent=kube-addon-manager|grep Running && \
          #        kubectl get pods --namespace=kube-system -lk8s-app=kube-dns|grep Running ; then
          #       break
          #     fi
          #     sleep 2
          #   done
          - echo "=========================================================================================="
          - minikube status
          - kubectl cluster-info
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "=========================================================================================="
fleet_script_minikube_tasks : &fleet_script_minikube_tasks
      script:
          # local env variables not globals
          # - grep -E --color 'vmx|svm' /proc/cpuinfo #check if virtualization is supported on Linux
          - export MINIKUBE_WANTUPDATENOTIFICATION=false
          - export MINIKUBE_WANTREPORTERRORPROMPT=false
          - export CHANGE_MINIKUBE_NONE_USER=true
          - export KUBECTL_VERSION=1.18.3 #https://kubernetes.io/docs/tasks/tools/install-kubectl/
          - export KUBERNETES_VERSION=1.18.3
          - export MINIKUBE_VERSION=1.18.3 #https://kubernetes.io/docs/tasks/tools/install-minikube/
          - sudo apt-get -qq -y install conntrack #http://conntrack-tools.netfilter.org/
          - curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/v$KUBECTL_VERSION/bin/linux/amd64/kubectl && chmod +x kubectl && sudo mv kubectl /usr/local/bin/ # Download kubectl
          - curl -Lo minikube https://storage.googleapis.com/minikube/releases/v$MINIKUBE_VERSION/minikube-linux-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/ # Download minikube
          - mkdir -p $HOME/.kube $HOME/.minikube
          - touch $KUBECONFIG
          - sudo minikube start --profile=minikube --vm-driver=none --kubernetes-version=v$KUBERNETES_VERSION #--vm-driver=none, doesn't use a VM, but containers the none driver, the kubectl config and credentials generated are owned by root in the root user’s home directory
          - minikube update-context --profile=minikube
          - "sudo chown -R travis: /home/travis/.minikube/"
          - eval "$(minikube docker-env --profile=minikube)" && export DOCKER_CLI='docker'
          - echo "=========================================================================================="
          - kubectl version --client #ensure the version
          - kubectl cluster-info
          - minikube status
          - echo "=========================================================================================="
          - |
            JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}';
            until kubectl -n kube-system get pods -lk8s-app=kube-dns -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do
              sleep 1;
              echo "waiting for kube-dns to be available";
              kubectl get pods --all-namespaces;
            done
          - kubectl run travis-example --image=redis --labels="app=travis-example" # Create example Redis deployment on Kubernetes.
          - | # Make sure created pod is scheduled and running.
            JSONPATH='{range .items[*]}{@.metadata.name}:{range @.status.conditions[*]}{@.type}={@.status};{end}{end}';
            until kubectl -n default get pods -lapp=travis-example -o jsonpath="$JSONPATH" 2>&1 | grep -q "Ready=True"; do
              sleep 1;
              echo "waiting for travis-example deployment to be available";
              kubectl get pods -n default;
            done
          - echo "============================================="
          - kubectl get pods --all-namespaces;
          - kubectl get pods -n default;
          - echo "============================================="
fleet_script_tasks : &fleet_script_tasks
      script:
        - python --version
fleet_install_tasks : &fleet_install_tasks
      install:
        - pip install -r requirements.txt


matrix:
  fast_finish: true
  include:

    - name: "minikube linkerd Python 3.7 on bionic" #OK
      dist: bionic
      language: python
      python: 3.7
      before_install:
        - pip3 install virtualenv
        - virtualenv -p $(which python3) ~venvpy3
        - source ~venvpy3/bin/activate
      <<: *fleet_install_tasks
      <<: *fleet_script_tasks
      <<: *fleet_script_linkerd_tasks
      after_success:
        - deactivate

    # - name: "minikube service mesh istio knative ambassador serverless  Python 3.7 on bionic"
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_minikube_knative_ambassador_serverless_tasks
    #   after_success:
    #     - deactivate

    # - name: "minikube service mesh istio knative Python 3.7 on bionic"
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_minikube_knative_tasks
    #   after_success:
    #     - deactivate

    # - name: "packer latest Python 3.7 on bionic" #OK
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_packer_latest_tasks
    #   after_success:
    #     - deactivate

    # - name: "minikube microservice Python 3.7 on bionic" #OK
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   # <<: *fleet_script_vagrant_tasks
    #   <<: *fleet_script_vagrant_latest_tasks
    #   # <<: *fleet_script_minikube_tasks
    #   after_success:
    #     - deactivate

    # - name: "minikube latest microservice Python 3.7 on xenial" #OK
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   # <<: *fleet_script_vagrant_tasks
    #   <<: *fleet_script_minikube_latest_tasks
    #   after_success:
    #     - deactivate

    # - name: "Python 3.7 on bionic arm64" # package architecture (amd64) does not match system (arm64)
    #   os: linux
    #   arch: arm64
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on bionic ppc64le" #Unable to locate package osquery
    #   os: linux
    #   arch: ppc64le
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on bionic s390x" #Unable to locate package osquery
    #   os: linux
    #   arch: s390x
    #   dist: bionic
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate


    # - name: "Python 2.7 on xenial amd64"
    #   dist: xenial
    #   language: python
    #   python: 2.7
    #   before_install:
    #     - pip install virtualenv
    #     - virtualenv -p $(which python2) ~venvpy2
    #     - source ~venvpy2/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   # <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate

    # - name: "Python 3.7 on xenial arm64"
    #   os: linux
    #   arch: arm64
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on xenial ppc64le" #Unable to locate package osquery
    #   os: linux
    #   arch: ppc64le
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on xenial s390x" #Unable to locate package osquery
    #   os: linux
    #   arch: s390x
    #   dist: xenial
    #   language: python
    #   python: 3.7
    #   # env:
    #   #   - LIB_PATH="/usr/bin/shared/x86_64/v1"
    #   # compiler:
    #   #  - gcc
    #   #  - clang
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_tasks
    #   after_success:
    #     - deactivate




    # - name: "Python 2.7.17 on macOS xcode10.2"
    #   os: osx
    #   osx_image: xcode10.2
    #   language: shell
    #   before_install:
    #     - pip install virtualenv
    #     - virtualenv -p $(which python2) ~venvpy2
    #     - source ~venvpy2/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_macos_tasks
    #   after_success:
    #     - deactivate
    #
    #
    #
    #
    # - name: "Python 3.7.5 on macOS xcode10.2"
    #   os: osx
    #   osx_image: xcode10.2
    #   language: shell
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_macos_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7.5 on macOS xcode9.4 "
    #   os: osx
    #   osx_image: xcode9.4
    #   language: shell
    #   before_install:
    #     - pip3 install virtualenv
    #     - virtualenv -p $(which python3) ~venvpy3
    #     - source ~venvpy3/bin/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_macos_tasks
    #   after_success:
    #     - deactivate



    # - name: "Python 3.8 on Windows"
    #   os: windows
    #   language: shell
    #   env:
    #     - PATH=/c/Python38:/c/Python38/Scripts:$PATH
    #   before_install:
    #     - choco install python --version 3.8.1
    #     - pip install virtualenv
    #     - virtualenv $HOME/venv
    #     - source $HOME/venv/Scripts/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_win_tasks
    #   <<: *fleet_script_vagrant_win_scoop_tasks
    #   after_success:
    #     - deactivate
    #
    # - name: "Python 3.7 on Windows"
    #   os: windows
    #   language: shell
    #   env: PATH=/c/Python37:/c/Python37/Scripts:$PATH
    #   before_install:
    #     - choco install python --version 3.7.3
    #     - python -m pip install virtualenv
    #     - virtualenv $HOME/venv
    #     - source $HOME/venv/Scripts/activate
    #   <<: *fleet_install_tasks
    #   <<: *fleet_script_tasks
    #   <<: *fleet_script_vagrant_win_tasks
    #   <<: *fleet_script_vagrant_win_scoop_tasks
    #   after_success:
    #     - deactivate
